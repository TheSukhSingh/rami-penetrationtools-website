from datetime import datetime, timezone
from flask import (
    render_template, request, abort, redirect, url_for,
    current_app, make_response
)
from sqlalchemy import or_
from itsdangerous import URLSafeTimedSerializer, BadSignature, SignatureExpired
from email.utils import format_datetime
from xml.sax.saxutils import escape as xml_escape
from . import blog_bp
from .models import Post, Category, Tag, SlugRedirect, PostStatus


# --------- helpers ---------
def _now_utc_naive():
    # Assuming your DB timestamps are naive UTC
    return datetime.utcnow()

def _now_utc():
    return datetime.utcnow().replace(tzinfo=timezone.utc)

def _is_publicly_visible(post: Post) -> bool:
    if post.status != PostStatus.PUBLISHED.value:
        return False
    # If published_at is set, it must be <= now; if somehow None, treat as public
    return (post.published_at is None) or (post.published_at <= _now_utc_naive())

def _serializer():
    # You can set BLOG_PREVIEW_SECRET in config to decouple from app.secret_key
    secret = current_app.config.get("BLOG_PREVIEW_SECRET") or current_app.secret_key
    return URLSafeTimedSerializer(secret_key=secret, salt="blog-preview")

def _token_valid_for_post(token: str, post: Post) -> bool:
    """Accepts tokens generated by your admin. Expected payload:
       {'post_id': <int>} OR {'slug': '<slug>'}. Max age configurable.
    """
    if not token:
        return False
    s = _serializer()
    max_age = int(current_app.config.get("BLOG_PREVIEW_MAX_AGE", 60 * 60 * 48))  # 48h default
    try:
        data = s.loads(token, max_age=max_age)
    except (BadSignature, SignatureExpired):
        return False

    if isinstance(data, dict):
        if "post_id" in data and str(data["post_id"]) == str(post.id):
            return True
        if "slug" in data and str(data["slug"]) == str(post.slug):
            return True
        # If you prefer a generic token (not tied to a post), allow a boolean flag:
        if data.get("preview") is True:
            return True
    return False

def _noindex(resp):
    resp.headers["X-Robots-Tag"] = "noindex, nofollow"
    return resp


# --------- routes ---------
@blog_bp.route("/")
def index():
    """Public blog index with optional search, category and tag filters."""
    page = max(int(request.args.get("page", 1)), 1)
    per_page = int(current_app.config.get("BLOG_PAGE_SIZE", 10))

    q   = (request.args.get("q") or "").strip()
    cat = (request.args.get("cat") or "").strip()  # category slug
    tag = (request.args.get("tag") or "").strip()  # tag slug

    qry = Post.query.filter(
        Post.status == PostStatus.PUBLISHED.value,
        (Post.published_at == None) | (Post.published_at <= _now_utc_naive())  # noqa: E711
    ).order_by(Post.published_at.desc())

    if q:
        like = f"%{q}%"
        qry = qry.filter(or_(Post.title.ilike(like), Post.summary.ilike(like)))

    if cat:
        qry = qry.join(Category).filter(Category.slug == cat)

    if tag:
        qry = qry.join(Post.tags).filter(Tag.slug == tag)

    items = qry.paginate(page=page, per_page=per_page, error_out=False)
    return render_template("blog/index.html", items=items, q=q, cat=cat, tag=tag)


@blog_bp.route("/<slug>")
def detail(slug):
    """Post detail. Unpublished/scheduled require a valid preview token."""
    post = Post.query.filter_by(slug=slug).first()

    # If not found, attempt a slug redirect (legacy link support)
    if not post:
        red = SlugRedirect.query.filter_by(entity="post", old_slug=slug).first()
        if red:
            return redirect(url_for("blog.detail", slug=red.new_slug), code=301)
        abort(404)

    # Publicly visible? Show normally.
    if _is_publicly_visible(post):
        return render_template("blog/detail.html", post=post)

    # Otherwise require preview token (e.g., draft, in_review, or future scheduled)
    token = request.args.get("preview")
    if not _token_valid_for_post(token, post):
        # don't leak existence
        abort(404)

    # Preview: render but ensure no indexing
    resp = make_response(render_template("blog/detail.html", post=post, is_preview=True))
    return _noindex(resp)


@blog_bp.route("/category/<slug>")
def by_category(slug):
    """Category landing page (published posts only)."""
    category = Category.query.filter_by(slug=slug).first_or_404()
    page = max(int(request.args.get("page", 1)), 1)
    per_page = int(current_app.config.get("BLOG_PAGE_SIZE", 10))

    qry = (Post.query
           .filter(Post.category_id == category.id,
                   Post.status == PostStatus.PUBLISHED.value,
                   (Post.published_at == None) | (Post.published_at <= _now_utc_naive()))  # noqa: E711
           .order_by(Post.published_at.desc()))
    items = qry.paginate(page=page, per_page=per_page, error_out=False)
    return render_template("blog/category.html", category=category, items=items)


@blog_bp.route("/tag/<slug>")
def by_tag(slug):
    """Tag landing page (published posts only)."""
    tag = Tag.query.filter_by(slug=slug).first_or_404()
    page = max(int(request.args.get("page", 1)), 1)
    per_page = int(current_app.config.get("BLOG_PAGE_SIZE", 10))

    qry = (Post.query.join(Post.tags)
           .filter(Tag.id == tag.id,
                   Post.status == PostStatus.PUBLISHED.value,
                   (Post.published_at == None) | (Post.published_at <= _now_utc_naive()))  # noqa: E711
           .order_by(Post.published_at.desc()))
    items = qry.paginate(page=page, per_page=per_page, error_out=False)
    return render_template("blog/tag.html", tag=tag, items=items)



@blog_bp.route("/rss.xml")
def rss_feed():
    """
    RSS 2.0 feed of the latest published posts (max 20).
    Public-only: shows posts where status='published' and published_at <= now.
    """
    # Config knobs (safe defaults)
    site_url = (current_app.config.get("SITE_URL") or request.url_root).rstrip("/")
    feed_title = current_app.config.get("BLOG_TITLE", "Hackr.gg Blog")
    feed_desc = current_app.config.get("BLOG_DESCRIPTION", "Latest posts from Hackr.gg")
    feed_link = f"{site_url}/blog"
    self_link = f"{site_url}/blog/rss.xml"

    # Query latest 20 public posts
    now = datetime.utcnow()
    posts = (
        Post.query
        .filter(
            Post.status == PostStatus.PUBLISHED.value,
            (Post.published_at == None) | (Post.published_at <= now)  # noqa: E711
        )
        .order_by(Post.published_at.desc())
        .limit(20)
        .all()
    )

    # Build channel metadata
    last_build = None
    if posts and posts[0].published_at:
        # treat stored datetime as UTC
        last_build = posts[0].published_at.replace(tzinfo=timezone.utc)
    else:
        last_build = _now_utc()

    # Compose RSS XML (simple and fast; no extra template file)
    items_xml = []
    for p in posts:
        pub = p.published_at.replace(tzinfo=timezone.utc) if p.published_at else _now_utc()
        url = f"{site_url}/blog/{p.slug}"
        title = xml_escape(p.title or "")
        description = xml_escape(p.summary or "")
        guid = url  # stable URL as GUID

        # Optional media enclosure (cover image)
        enclosure = ""
        if p.cover_path:
            enclosure = f'\n      <enclosure url="{xml_escape(site_url + p.cover_path)}" type="image/*" />'

        items_xml.append(
            "    <item>\n"
            f"      <title>{title}</title>\n"
            f"      <link>{xml_escape(url)}</link>\n"
            f"      <guid isPermaLink=\"true\">{xml_escape(guid)}</guid>\n"
            f"      <pubDate>{format_datetime(pub)}</pubDate>\n"
            f"      <description><![CDATA[{p.summary or ''}]]></description>{enclosure}\n"
            "    </item>"
        )

    xml = (
        '<?xml version="1.0" encoding="UTF-8"?>\n'
        "<rss version=\"2.0\">\n"
        "  <channel>\n"
        f"    <title>{xml_escape(feed_title)}</title>\n"
        f"    <link>{xml_escape(feed_link)}</link>\n"
        f"    <description>{xml_escape(feed_desc)}</description>\n"
        f"    <lastBuildDate>{format_datetime(last_build)}</lastBuildDate>\n"
        f"    <atom:link href=\"{xml_escape(self_link)}\" rel=\"self\" type=\"application/rss+xml\" "
        "xmlns:atom=\"http://www.w3.org/2005/Atom\" />\n"
        + ("\n".join(items_xml) if items_xml else "")
        + "\n  </channel>\n</rss>\n"
    )

    resp = make_response(xml, 200)
    resp.mimetype = "application/rss+xml; charset=utf-8"
    # Caching hint for CDNs/browsers (tweak as you like)
    resp.headers["Cache-Control"] = "public, max-age=300"
    return resp